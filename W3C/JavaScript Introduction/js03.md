# Module 3: Playing with HTML5 APIs

## 1. 陣列（Array）

- 索引從 0 開始；最後一個為 `arr.length - 1`
- 常用屬性/方法：
    - `length`：元素數量
    - `push()` / `pop()`：尾端增刪
    - `sort([compare])`：就地排序（字串預設字典序，數字需比較函式）
    - `splice(start, deleteCount, ...items)`：就地刪除/插入，回傳刪除元素陣列
- 避免：
    - `delete arr[i]` 會留下空洞
    - 設定過遠索引產生空洞
- 建議不可變操作前先複製：`[...arr]` 或 `arr.slice()`

```jsx
// 數字排序（複製避免改原陣列）
const sorted = [...nums].sort((a, b) => a - b);

// 物件陣列排序（依年齡）
persons.sort((a, b) => a.age - b.age);

// 文字排序（本地化比較）
people.sort((a, b) => a.name.localeCompare(b.name, 'zh-Hant'));
```

## 2. 字串（String）

- 像陣列可用索引與 `.length`，但不可變
- 修改需回傳新字串

```jsx
let s = 'Michel';
s = 'Hello ' + s;
s = s.replace('Michel', 'JS');

// 刪除一段
const delAt = (s, start, count) => s.slice(0, start) + s.slice(start + count);

// 取代某位置字元
const replaceAt = (s, i, ch) => s.slice(0, i) + ch + s.slice(i + ch.length);
```

---

## 3. 陣列迭代策略

- `forEach()`：語意清楚，無法 `break/continue`
- `for` 傳統迴圈：可完全控制
- `for...of`：簡潔遍歷值
- 轉換/過濾：優先 `map()`、`filter()`、`reduce()`

---

## 4. HTML5 視音訊基礎

```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4" />
  <source src="movie.webm" type="video/webm" />
  Your browser does not support the <video> element.
</video>
```

- 可用 CSS 與 JS 操作
- YouTube 請用 `<iframe>`
- `<audio>` 同理，多 `<source>` 提供格式

---

## 5. 視音訊 JavaScript API

- 方法：`play()`、`pause()`、`load()`
- 屬性：`currentTime`、`duration`、`paused`、`muted`、`volume`
- 事件：`timeupdate`、`ended`、`play`、`pause`、`error`

```html
<video id="vid" controls src="/assets/video.webm"></video>
<button id="play">Play</button>
<script>
  const vid = document.querySelector('#vid');
  play.onclick = () => vid.play();
</script>
```

---

## 6. 播放清單範例

```jsx
const playlist = ['a.mp4','b.mp4','c.mp4'];
let idx = 0;
const vid = document.querySelector('#myVideo');

function loadAndPlay(i){
  const cur = playlist[i % playlist.length];
  const { volume, playbackRate } = vid;
  vid.src = cur; vid.load();
  vid.onloadedmetadata = () => {
    vid.volume = volume; vid.playbackRate = playbackRate; vid.play();
  };
}
vid.addEventListener('ended', () => loadAndPlay(++idx));
loadAndPlay(idx);
```

---

## 7. 播放監測與錯誤處理

- 錯誤碼：`video.error.code`（NETWORK, DECODE, SRC_NOT_SUPPORTED…）
- 緩衝百分比：

```jsx
const end = vid.buffered.length ? vid.buffered.end(vid.buffered.length-1) : 0;
const percent = (end / vid.duration) * 100;
```

---

## 8. 取得攝影機（getUserMedia）

```jsx
async function startCam(){
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  document.querySelector('video').srcObject = stream;
}
```

- 需 HTTPS 與授權
- 停止：`stream.getTracks().forEach(t => t.stop())`

---

## 9. 地理定位 + 地圖（Leaflet）

```jsx
navigator.geolocation.getCurrentPosition(success, error, {
  enableHighAccuracy: true, timeout: 8000
});
```

```jsx
const map = L.map('map').setView([lat, lng], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
L.marker([lat, lng]).addTo(map).bindPopup('Your location').openPopup();
```

---

## 10. 音訊（Howler）

```html
<script src="https://unpkg.com/howler"></script>
<script>
  const sfx = new Howl({ src: ['plop.mp3'] });
  sfx.play();
</script>
```

---

## 11. 多媒體資源載入器

```jsx
function loadAssets(list, onProgress){
  // 遍歷 list 載入 image/audio
}
```

- 宣告清單 → 載入完成後啟動主程式

---

## 12. 範例與專題點子

- 自訂播放器 + 清單
- 影片小測驗
- 地圖表單
- 音樂控制（多首、音量、靜音）
- 資產載入器 + 進度條

---

## 13. 速查表（API 名稱）

- 視音訊方法：`play()`、`pause()`、`load()`
- 屬性：`currentTime`、`duration`、`paused`、`volume`、`muted`、`buffered`
- Geolocation：`getCurrentPosition`、`watchPosition`
- MediaDevices：`getUserMedia()`
- Leaflet：`L.map()`、`L.tileLayer()`、`L.marker()`
- Howler：`new Howl()`、`.play()`

---

## 14. 實作

- `splice` 移除元素
- 物件陣列排序
- `replaceAt()` 改字元
- 影片 5 秒暫停出題
- 音樂播放清單
- 攝影機拍照到 `<canvas>`
- Leaflet 定位與地址
- Howler SFX 與音量控制
- 資產載入器進度條

---

## 15. 參考資源

- MDN：Array / String / HTMLMediaElement / Geolocation / MediaDevices
- Leaflet.js / Howler.js 官方文件

---

## 16. 總結

- 陣列：`push/pop/splice/sort` 基礎必備（注意就地修改）
- 字串：不可變，用 `slice`/`replace` 建新字串
- 視音訊：先會播，再用 JS 加強控制與互動
- 裝置 API：需權限與 HTTPS，錯誤處理與 UX 必備
- 模組化思維：外部庫 + 資產管理 提升維護性